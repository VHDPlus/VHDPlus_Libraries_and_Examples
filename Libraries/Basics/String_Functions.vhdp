Class
{
    --Creates the RAM instance for the string
    StepFunction newString
    (
        oString : String_Type;
    )
    {
        NewComponent Single_Port_RAM
        (
            Width    => 256,
            
            Write    => oString.Write,
            Address  => oString.Address,
            Data_IN  => oString.Data_IN,
            Data_OUT => oString.Data_OUT,
        );
        
        FunctionContent
        {
            oString.Length <= 0;
        }
    }
    
    --Creates a ROM instance with the string value (e.g. "example")
    StepFunction assignString
    (
        strValue : STD_LOGIC_VECTOR;
        oString  : String_Type;
    )
    {
        NewComponent Single_Port_ROM
        (
            Data     => strValue,
            
            Length   => oString.Length,
            Address  => oString.Address,
            Data_OUT => oString.Data_OUT,
        );
        
        FunctionContent
        {
            
        }
    }
    
    --iString1 + iString2 = oString
    --String = RAM interface + string length
    StepFunction stringConcat
    (
        iString1 : String_Type;
        
        iString2 : String_Type;
        
        oString  : String_Type;
    )
    {
        oString.Write <= '1';
        StepFor(oString.Length <= 0; oString.Length < iString1.Length; oString.Length <= oString.Length + 1)
        {
            iString1.Address <= oString.Length;
            Step
            {
                oString.Address <= oString.Length;
                oString.Data_IN <= iString1.Data_OUT;
            }
        }
        StepFor(; oString.Length < iString1.Length + iString2.Length; oString.Length <= oString.Length + 1)
        {
            iString2.Address <= oString.Length - iString1.Length;
            Step
            {
                oString.Address <= oString.Length;
                oString.Data_IN <= iString2.Data_OUT;
            }
        }
        oString.Write <= '0';
    }
    
    --oString + iString = oString
    StepFunction stringAppend
    (
        iString  : String_Type;
        
        oString  : String_Type;
    )
    {
        oString.Write <= '1';
        StepFor(VARIABLE appendCount : NATURAL := 0; appendCount < iString.Length; appendCount := appendCount + 1)
        {
            iString.Address <= appendCount;
            Step
            {
                oString.Address <= oString.Length;
                oString.Data_IN <= iString.Data_OUT;
                oString.Length  <= oString.Length + 1;
            }
        }
        oString.Write <= '0';
    }
    
    --Converts natural to string
    --Important: Needs BinaryToBcd and BinaryToBsdDigit
    StepFunction naturalToString
    (
        iNatural : NATURAL;
        oString  : String_Type;
        
        bcdEna   : STD_LOGIC;
        bcdBus   : STD_LOGIC;
        bcdBin   : STD_LOGIC_VECTOR;
        bcdDec   : STD_LOGIC_VECTOR;
    )
    {
        bcdBin <= STD_LOGIC_VECTOR(TO_UNSIGNED(iNatural, bcdBin'LENGTH));
        bcdEna <= '1';
        While(bcdBus = '0'){}
        bcdEna <= '0';
        While(bcdBus = '1'){}
        oString.Length <= 0;
        StepFor(VARIABLE charConvCounter : NATURAL range 0 to bcdDec'LENGTH/4 := bcdDec'LENGTH/4-1; charConvCounter > 0; charConvCounter := charConvCounter - 1)
        {
            If(oString.Length > 0 OR charConvCounter = 1 OR bcdDec((charConvCounter*4 - 1) downto (charConvCounter*4 - 4)) /= "0000")
            {
                oString.Write   <= '1';
                oString.Address <= oString.Length;
                oString.Data_IN <= "0011" & bcdDec((charConvCounter*4 - 1) downto (charConvCounter*4 - 4));
                oString.Length  <= oString.Length + 1;
            }
        }
        oString.Write  <= '0';
    }
}