--Press the button to start
--Set the trigger channel and the trigger edge

Main
(
    Button      : IN STD_LOGIC;
    
    Inputs      : IN STD_LOGIC_VECTOR (8-1 downto 0) := (others => '0');
    
    Test_Signal : OUT STD_LOGIC := '0';  --50khz signal
    Test_TX     : OUT STD_LOGIC;         --tx signal can be used as to test logic analyzer
    
    TX          : OUT STD_LOGIC;
    RX          : IN  STD_LOGIC;
)
{
    CONSTANT GraphName : STD_LOGIC_VECTOR := s"Channel ";
    CONSTANT TimeUnit  : STD_LOGIC_VECTOR := s"ns";
    CONSTANT NameChars : NATURAL := 10;
    
    CONSTANT Max_Samples   : NATURAL := 5000;
    CONSTANT Start_Offset  : NATURAL := 50;
    CONSTANT Channels      : NATURAL := 8;          --Only shows correct name from 0-19
    CONSTANT CLK_Frequency : NATURAL := 100000000;  --100MHz
    CONSTANT Baud_Rate     : NATURAL := 1000000;    --1 mega baud
    CONSTANT Trig_Timeout  : NATURAL := 100000000;  --Show output after 100ms if no trigger point
    
    SIGNAL Sample_Rate   : NATURAL range 1 to CLK_Frequency := 100000000; --100MHz
    SIGNAL Trig_Falling  : NATURAL range 0 to 1             := 0;         --rising edge
    SIGNAL Trig_Channel  : NATURAL range 0 to Channels      := 0;         --no trigger -> directly after button pressed

    
    SIGNAL CLK_100 : STD_LOGIC;
    NewComponent PLL
    (
        inclk0 => CLK,
        c0     => CLK_100,
    );
    
    
    Process Capture ()
    {
        If(rising_edge(CLK_100))
        {
            Thread
            {
                While(Button = '0')
                {
                    Wait(10ms);
                }
                While(Button = '1')
                {
                    Wait(10ms);
                }
                
                --Find trigger edge
                If(Trig_Channel < Channels)
                {
                    VARIABLE timeout_cntr : NATURAL range 0 to Trig_Timeout := 0;
                    timeout_cntr := 0;
                    While((Inputs(Trig_Channel) = '0' XOR Trig_Falling = 0) AND timeout_cntr < Trig_Timeout){ timeout_cntr := timeout_cntr + 1; }
                    While((Inputs(Trig_Channel) = '0' XOR Trig_Falling = 1) AND timeout_cntr < Trig_Timeout){ timeout_cntr := timeout_cntr + 1; }
                }
                
                --Fill logic analyzer with ADC data
                Logic_Analyzer_Run <= '1';
                While(Logic_Analyzer_Full = '0'){}
                Logic_Analyzer_Run <= '0';
                
                --Send saved data
                For(Logic_Analyzer_Address <= 0; Logic_Analyzer_Address < Max_Samples; Logic_Analyzer_Address <= Logic_Analyzer_Address + 1)
                {
                    For(VARIABLE cur_channel : NATURAL := 0; cur_channel < Channels; cur_channel := cur_channel + 1)
                    {
                        If(cur_channel > 9) { Plotter_Graph_Name <= GraphName & s"1" & STD_LOGIC_VECTOR(TO_UNSIGNED(cur_channel-10+48, 8)); }
                        Else { Plotter_Graph_Name <= GraphName & STD_LOGIC_VECTOR(TO_UNSIGNED(cur_channel+48, 8)) & x"00"; }
                        If(Logic_Analyzer_Outputs(cur_channel) = '1') { Plotter_Value <= 1; }
                        Else { Plotter_Value <= 0; }
                        Plotter_Time       <= (Logic_Analyzer_Address-Start_Offset) * (1000000000/Sample_Rate);      --Sample rate to nano seconds
                        --Send to plotter
                        Plotter_Send <= '1';
                        While(Plotter_Busy = '0'){}
                        Plotter_Send <= '0';
                        While(Plotter_Busy = '1'){}
                    }
                }
            }
        }
    }
    
    Process Settings ()
    {
        Thread
        {
            --Read string from console in "readStr"
            NewFunction newString (readStr);                       --Create string
            NewFunction readString (readStr, UART_Interface_RX_Data, UART_Interface_RX_Busy);  --Read uart message in string
            SIGNAL channel_i : INTEGER;
            SIGNAL rate_i    : INTEGER;
            SIGNAL fall_i    : INTEGER;
            --Check if received string is channel or sample rate setting
            rate_i    <= -1;                                       --Set sample rate index to -1 if indexof is skipped
            NewFunction indexOf (readStr, s"c", 1, 0, channel_i);  --Find index of c: "c3" <- 0  "r10000" <- -1
            If(channel_i /= 0)                                     --check if message was channel setting
            {
                NewFunction indexOf (readStr, s"r", 1, 0, rate_i); --Find index of r: "r10000" <- 0
            }
            If(channel_i /= 0 AND rate_i /= 0)
            {
                NewFunction indexOf (readStr, s"f", 1, 0, fall_i); --Find index of t: "f1" <- 0
            }
            If(rate_i = 0 OR channel_i = 0 OR fall_i = 0) --check if received string is channel or sample rate setting
            {
                --Convert received string to value of new sample rate or adc channel
                NewFunction newString (convertStr);                --create string for the number in the message
                NewFunction substring (readStr, 1, readStr.Length-1, convertStr);  --remove first char in message: "c3" -> "3", "r10000" -> "10000"
                SIGNAL receivedValue : NATURAL;
                NewFunction stringToNatural (convertStr, receivedValue); --Convert string to number
                if(rate_i = 0 AND receivedValue > 0 AND receivedValue <= CLK_Frequency) --check if sample rate is from 1 - 100,000,000
                {
                    Sample_Rate <= receivedValue;                  --set new sample rate
                }
                Elsif(channel_i = 0 AND receivedValue < Channels)  --check if channel is from 0 - Channel-1
                {
                    Trig_Channel <= receivedValue;                 --set new trigger channel
                }
                Elsif(fall_i = 0 AND receivedValue < 2)            --check if falling/rising edge setting is 0 or 1
                {
                    Trig_Falling <= receivedValue;                 --set new trigger falling/rising edge setting
                }
            }
        }
    }
    
    --Create 50 kHz signal to test input
    Process Test ()
    {
        Thread
        {
            --A bit lower frequency because Wait and setting the value also take 1 clock cycle
            Test_Signal <= '0';
            Wait(10us);
            Test_Signal <= '1';
            Wait(10us);
        }
    }
    
    --Create a uart test signal (sends "Test\n" on repeat)
    Process ()
    {
        Thread
        {
            NewFunction newConstString (s"Test\n", testStr);
            NewFunction printString (testStr, UART_Interface_TX_Data, UART_Interface_TX_Busy, UART_Interface_TX_Enable);
            Wait(50us);
        }
    }
    
    SIGNAL UART_Interface_TX_Enable     : STD_LOGIC := '0';
    SIGNAL UART_Interface_TX_Busy       : STD_LOGIC := '0';
    SIGNAL UART_Interface_TX_Data       : STD_LOGIC_VECTOR (8-1 DOWNTO 0) := (others => '0');
    SIGNAL UART_Interface_RX_Busy       : STD_LOGIC := '0';
    SIGNAL UART_Interface_RX_Data       : STD_LOGIC_VECTOR (8-1 DOWNTO 0) := (others => '0');
    NewComponent UART_Interface
    (
        CLK_Frequency => CLK_Frequency,
        Baud_Rate     => Baud_Rate,

        CLK           => CLK_100,
        TX            => Test_TX,
        RX            => RX,
        TX_Enable     => UART_Interface_TX_Enable,
        TX_Busy       => UART_Interface_TX_Busy,
        TX_Data       => UART_Interface_TX_Data,
        RX_Data       => UART_Interface_RX_Data,
        RX_Busy       => UART_Interface_RX_Busy,
    );
    
    SIGNAL Logic_Analyzer_Rate_Div      : NATURAL          range 1 to CLK_Frequency := 12;
    SIGNAL Logic_Analyzer_Run           : STD_LOGIC := '0';
    SIGNAL Logic_Analyzer_Full          : STD_LOGIC := '0';
    SIGNAL Logic_Analyzer_Address       : NATURAL          range 0 to Max_Samples := 0;
    SIGNAL Logic_Analyzer_Outputs       : STD_LOGIC_VECTOR (Channels-1 downto 0);
    NewComponent Logic_Analyzer
    (
        Max_Samples   => Max_Samples,
        CLK_Frequency => CLK_Frequency,
        Channels      => Channels,
        Start_Offset  => Start_Offset,

        CLK           => CLK_100,
        Rate_Div      => Logic_Analyzer_Rate_Div,
        Start         => Logic_Analyzer_Run,
        Full          => Logic_Analyzer_Full,
        Inputs        => Inputs,
        Address       => Logic_Analyzer_Address,
        Outputs       => Logic_Analyzer_Outputs,
    );

    SIGNAL Plotter_Value         : INTEGER := 0;
    SIGNAL Plotter_Time          : INTEGER := 0;
    SIGNAL Plotter_Graph_Name    : STD_LOGIC_VECTOR (NameChars*8-1 downto 0) := (others => '0');
    SIGNAL Plotter_Send          : STD_LOGIC := '0';
    SIGNAL Plotter_Busy          : STD_LOGIC := '0';
    NewComponent Serial_Plotter_Interface
    (
        UseTime       => true,
        TimeUnit      => TimeUnit,
        NameChars     => NameChars,
        CLK_Frequency => CLK_Frequency,
        Baud_Rate     => Baud_Rate,

        CLK           => CLK_100,
        Value         => Plotter_Value,
        Time          => Plotter_Time,
        Graph_Name    => Plotter_Graph_Name,
        Send          => Plotter_Send,
        Busy          => Plotter_Busy,
        TX            => TX,
    );
}