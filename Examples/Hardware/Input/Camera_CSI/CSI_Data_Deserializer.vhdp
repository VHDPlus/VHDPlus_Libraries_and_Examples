Component CSI_Data_Deserializer
(
    d_lane  : IN STD_LOGIC_VECTOR (1 downto 0); --1 = Dp 0 = Dn
    bit_clk : IN STD_LOGIC;
    
    data_o  : OUT STD_LOGIC_VECTOR (7 downto 0);
    new_b   : OUT STD_LOGIC := '0';
    state   : OUT INTEGER range 0 to 15; --1-6 = Startbit, LPDT, Data ID, Data 0, Data 1, ECC, ?
)
{
    --Data = '1'
    SIGNAL dataIsOne : BOOLEAN := false;
    Process ()
    {
        If(rising_edge(d_lane(1)))
        {
            dataIsOne  <= NOT dataIsOne;
        }
    }
    
    --Save Data
    SIGNAL receiveState : INTEGER range 0 to 15 := 0;
    Process ()
    {
        If(falling_edge(bit_clk))
        {
            VARIABLE receivedData : STD_LOGIC_VECTOR := (others => '0');
            
            VARIABLE oneReg : BOOLEAN := false;

            If(startFound)
            {
                receiveState <= 1;
            }
            Elsif(endFound)
            {
                receiveState <= 0;
                state <= 0;
            }
            Elsif(oneReg /= dataIsOne)
            {
                receivedData := '1' & receivedData(7 downto 1);
            }
            Else
            {
                receivedData := '0' & receivedData(7 downto 1);
            }
            
            VARIABLE bitCount : INTEGER range 0 to 7 := 0;
            If(startFound)
            {
                receivedData := (others => '0');
            }
            Elsif(receiveState > 0)
            {
                If(bitCount < 7 AND receiveState > 1)
                {
                    bitCount := bitCount + 1;
                    new_b <= '0';
                }
                Else
                {
                    data_o <= receivedData;
                    If(receiveState > 1)
                    {
                        new_b <= '1';
                    }
                    receivedData := (others => '0');
                    state <= receiveState;
                    bitCount := 0;
                    If(receiveState < 15)
                    {
                        receiveState <= receiveState + 1;
                    }
                    Else
                    {
                        receiveState <= 0;
                    }
                }
            }

            oneReg  := dataIsOne;
        }
    }
    
    --Start finder
    SIGNAL startFound : BOOLEAN := true;
    Process ()
    {
        If(receiveState = 1)
        {
            startFound <= false;
        }
        Elsif(falling_edge(d_lane(0)))
        {
            If(d_lane(1) = '1')
            {
                startFound <= true;
            }
        }
    }
    
    --End finder
    SIGNAL endFound : BOOLEAN := true;
    Process ()
    {
        If(receiveState = 0)
        {
            endFound <= false;
        }
        Elsif(rising_edge(d_lane(0)))
        {
            If(d_lane(1) = '1')
            {
                endFound <= true;
            }
        }
    }
}