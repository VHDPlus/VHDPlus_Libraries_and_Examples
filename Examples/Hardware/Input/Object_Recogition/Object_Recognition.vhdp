Main
(
    Camera_CLK_Lane      : IN     STD_LOGIC;
    Camera_Data_Lane     : IN     STD_LOGIC_VECTOR (1 downto 0);
    Camera_Enable        : OUT    STD_LOGIC;
    Camera_SCL           : INOUT  STD_LOGIC;
    Camera_SDA           : INOUT  STD_LOGIC;
    
    oHDMI_TX             : OUT    STD_LOGIC_VECTOR(2 downto 0);
    oHDMI_CLK            : OUT    STD_LOGIC;
    iHDMI_HPD            : IN     STD_LOGIC;
)
{
    CONSTANT CLK_Frequency : NATURAL := 48000000;
    
    --Camera Input
    CONSTANT Row_Buf  : BOOLEAN := true; --Uses more RAM, but helps with less noise
    
    --Compression
    CONSTANT Enable_Compression  : BOOLEAN := true;  --Uses more RAM, decreases noise
    
    CONSTANT Compression_Area    : NATURAL := 4; --Bigger Area = less noise but higher RAM usage
    CONSTANT Min_Pixel_Num       : NATURAL := ((Compression_Area**2)/2)*1; --min 50% '1'
    
    --Blob Detection
    CONSTANT Blob_Min_H  : NATURAL := 5;   --< = Detect smaller blobs
    CONSTANT Blob_Min_W  : NATURAL := 5;
    CONSTANT Blob_Max_H  : NATURAL := 40;  --> = Detect bigger blobs
    CONSTANT Blob_Max_W  : NATURAL := 80;
    
    --Cone Detection
    CONSTANT Cone_31_Dist_Mult : NATURAL := 3; --Bigger = detect more cones but less accurate
    CONSTANT Cone_32_Dist_Mult : NATURAL := 2;
    
    --Capture and video output parameters
    CONSTANT Capture_Compression : NATURAL :=  2; --Higher value = less RAM but also less resolution
    CONSTANT Capture_Output      : NATURAL :=  5; --0 = Camera, 1 = Color Filter, 2 = HSV,
    --3 = Threshold with Color_Select color, 4 = Compressed, 5 = Blobs, 6 = Cones
    CONSTANT Capture_Color_Depth : NATURAL := 1; --4 for Capture_Output = 0 or 1; 8 for Capture_Output = 2; 1 for others
    CONSTANT Full_Image : BOOLEAN := true;
    CONSTANT Color_Out  : BOOLEAN := true;
    
    SIGNAL Color_Select : NATURAL range 0 to 3 := 2;
    SIGNAL Cone_Select  : NATURAL range 0 to 1 := 1;  --0 = Yellow-Black 1 = Blue-White
    
    --Camera Interface-------------------------------------------------------------------
    
    Camera_Enable <= '1';
    
    --Receive CSI Data
    SIGNAL Camera_Stream         : rgb_stream;
    
    NewComponent CSI_Camera
    (
        CLK_Frequency => CLK_Frequency,
        Row_Buf       => Row_Buf,
        
        Reset         => '0',
        CLK_Lane      => Camera_CLK_Lane,
        Data_Lane     => Camera_Data_Lane,
        SCL           => Camera_SCL,
        SDA           => Camera_SDA,
        
        oStream       => Camera_Stream,
    );
    
    --Color Filter-----------------------------------------------------------------------
    
    SIGNAL Color_Correction_Stream     : rgb_stream;
    
    NewComponent Color_Correction_Filter
    (
        CLK_Edge     => false,
        
        R_Multiplier => 1,
        R_Divider    => 1,
        R_Add        => 0,
        G_Multiplier => 3,
        G_Divider    => 5, --less green
        G_Add        => 0,
        B_Multiplier => 1,
        B_Divider    => 1,
        B_Add        => 0,
        
        iStream      => Camera_Stream,
        oStream      => Color_Correction_Stream,
    );
    
    --Convert color space (for color detection)------------------------------------------
    
    SIGNAL RGB2HSV_Stream       : rgb_stream;
    
    NewComponent RGB2HSV_Filter
    (
        CLK_Edge => true,
        
        iStream  => Color_Correction_Stream,
        oStream  => RGB2HSV_Stream,
    );
    
    --Color detection--------------------------------------------------------------------

    SIGNAL Yellow_Filter_Stream   : rgb_stream;
    
    NewComponent Color_Threshold_HSV_Filter
    (
        CLK_Edge   => false,
        
        H_Min      => 170,
        H_Max      => 40,
        S_Min      => 100,
        S_Max      => 255,
        V_Min      => 60,
        V_Max      => 255,
        
        iStream    => RGB2HSV_Stream,
        oStream    => Yellow_Filter_Stream,
    );
    
    SIGNAL Black_Filter_Stream   : rgb_stream;
    
    NewComponent Color_Threshold_HSV_Filter
    (
        CLK_Edge   => false,
        
        H_Min      => 0,
        H_Max      => 255,
        S_Min      => 0,
        S_Max      => 120,
        V_Min      => 0,
        V_Max      => 40,
        
        iStream    => RGB2HSV_Stream,
        oStream    => Black_Filter_Stream,
    );
    
    SIGNAL Blue_Filter_Stream   : rgb_stream;
    
    NewComponent Color_Threshold_HSV_Filter
    (
        CLK_Edge   => false,
        
        H_Min      => 105,
        H_Max      => 150,
        S_Min      => 120,
        S_Max      => 255,
        V_Min      => 50,
        V_Max      => 255,
        
        iStream    => RGB2HSV_Stream,
        oStream    => Blue_Filter_Stream,
    );
    
    SIGNAL White_Filter_Stream   : rgb_stream;
    
    NewComponent Color_Threshold_HSV_Filter
    (
        CLK_Edge   => false,
        
        H_Min      => 0,
        H_Max      => 255,
        S_Min      => 0,
        S_Max      => 120,
        V_Min      => 150,
        V_Max      => 255,
        
        iStream    => RGB2HSV_Stream,
        oStream    => White_Filter_Stream,
    );
    
    --Threshold Compression--------------------------------------------------------------
    
    SIGNAL Area_Compression_Pixel     : STD_LOGIC_VECTOR(3 downto 0);
    SIGNAL Area_Compression_New_Pixel : STD_LOGIC;
    SIGNAL Area_Compression_Column    : NATURAL range 0 to 639;
    SIGNAL Area_Compression_Row       : NATURAL range 0 to 479;
    
    Generate (if Enable_Compression)
    {
        NewComponent AreaLimitedCompression
        (
            Min_Pixel_Num => Min_Pixel_Num,  --10x10 = 100 -> 60/100 = min 60% blue
            MAX_Area      => Compression_Area,
            MIN_Area      => Compression_Area,
            Start_Row     => 0,
            Colors        => 4,
            CLK_Edge      => true,
            
            iNew_Pixel    => Yellow_Filter_Stream.New_Pixel,
            iColumn       => Yellow_Filter_Stream.Column,
            iRow          => Yellow_Filter_Stream.Row,
            
            iPixel(0)     => Yellow_Filter_Stream.R(0),
            iPixel(1)     => Black_Filter_Stream.R(0),
            iPixel(2)     => Blue_Filter_Stream.R(0),
            iPixel(3)     => White_Filter_Stream.R(0),
            
            oNew_Pixel    => Area_Compression_New_Pixel,
            oColumn       => Area_Compression_Column,
            oRow          => Area_Compression_Row,
            
            oPixel        => Area_Compression_Pixel,
        );
    }
    
    Generate (if NOT Enable_Compression)
    {
        Area_Compression_New_Pixel <= Yellow_Filter_Stream.New_Pixel;
        Area_Compression_Column    <= Yellow_Filter_Stream.Column;
        Area_Compression_Row       <= Yellow_Filter_Stream.Row;
        Area_Compression_Pixel(0)  <= Yellow_Filter_Stream.R(0);
        Area_Compression_Pixel(1)  <= Black_Filter_Stream.R(0);
        Area_Compression_Pixel(2)  <= Blue_Filter_Stream.R(0);
        Area_Compression_Pixel(3)  <= White_Filter_Stream.R(0);
    }
    
    --Blob detection---------------------------------------------------------------------
    
    TYPE Blob_Data IS RECORD
    Busy       : STD_LOGIC;
    Blobs      : NATURAL   range 0 to 32;
    Addr       : NATURAL   range 0 to 31;
    X0         : NATURAL   range 0 to Image_Width-1;
    X1         : NATURAL   range 0 to Image_Width-1;
    Y0         : NATURAL   range 0 to Image_Height-1;
    Y1         : NATURAL   range 0 to Image_Height-1;
    END RECORD Blob_Data;
    
    TYPE blob_array IS ARRAY (0 to 3) OF Blob_Data;
    SIGNAL blob_data_array : blob_array;
    
    Generate (for i in 0 to 3)
    {
        NewComponent Blob_Detect
        (
            Blob_Number     => 32,
            Blob_Buffer     => 8,
            Min_Blob_Width  => Blob_Min_W,
            Min_Blob_Height => Blob_Min_H,
            Max_Blob_Width  => Blob_Max_W,
            Max_Blob_Height => Blob_Max_H,
            Upscale_Mult    => 1,
            Upscale_Start   => 0,
            
            New_Pixel       => Area_Compression_New_Pixel,
            Pixel_In        => Area_Compression_Pixel(i),
            Column          => Area_Compression_Column,
            Row             => Area_Compression_Row,
            Blob_Busy       => blob_data_array(i).Busy,
            Blobs           => blob_data_array(i).Blobs,
            Blob_Addr       => blob_data_array(i).Addr,
            Blob_X0         => blob_data_array(i).X0,
            Blob_X1         => blob_data_array(i).X1,
            Blob_Y0         => blob_data_array(i).Y0,
            Blob_Y1         => blob_data_array(i).Y1,
        );
    }
    
    --Cone Detection (individual code with blobs)-------------------------------------------
    
    TYPE Cone_Data IS RECORD
    Busy     : STD_LOGIC;
    Cones    : NATURAL   range 0 to 16;
    Addr     : NATURAL   range 0 to 16-1;
    X        : NATURAL   range 0 to Image_Width-1;
    Y        : NATURAL   range 0 to Image_Height-1;
    END RECORD Cone_Data;
    
    TYPE cone_array IS ARRAY (0 to 1) OF Cone_Data;
    SIGNAL cone_data_array : cone_array;
    
    Generate (if Capture_Output = 6)
    {
        --Detect yellow and blue cones
        Generate (for i in 0 to 1)
        {
            NewComponent Cone_Detection
            (
                New_Pixel       => Area_Compression_New_Pixel,
                
                Blob_Number     => 32,
                Cone_Number     => 16,
                Max_11Dist_Mult => Cone_31_Dist_Mult,
                Max_11Dist_Div  => 1,
                Max_12Dist_Mult => Cone_32_Dist_Mult,
                Max_12Dist_Div  => 1,
                
                Blob_Busy_1     => blob_data_array(i*2).Busy,
                iBlobs_1        => blob_data_array(i*2).Blobs,
                iBlob_Addr_1    => blob_data_array(i*2).Addr,
                iBlob_X0_1      => blob_data_array(i*2).X0,
                iBlob_X1_1      => blob_data_array(i*2).X1,
                iBlob_Y0_1      => blob_data_array(i*2).Y0,
                iBlob_Y1_1      => blob_data_array(i*2).Y1,
                
                Blob_Busy_2     => blob_data_array(i*2+1).Busy,
                iBlobs_2        => blob_data_array(i*2+1).Blobs,
                iBlob_Addr_2    => blob_data_array(i*2+1).Addr,
                iBlob_X0_2      => blob_data_array(i*2+1).X0,
                iBlob_X1_2      => blob_data_array(i*2+1).X1,
                iBlob_Y0_2      => blob_data_array(i*2+1).Y0,
                iBlob_Y1_2      => blob_data_array(i*2+1).Y1,
                
                oBusy           => cone_data_array(i).Busy,
                oCones          => cone_data_array(i).Cones
                oCones_Addr     => cone_data_array(i).Addr,
                oCones_X        => cone_data_array(i).X,
                oCones_Y        => cone_data_array(i).Y,
            );
            
        }
    }
    
    --Draw Results---------------------------------------------------------------
    
    --Create stream with compression data
    SIGNAL Square_iStream : rgb_stream;
    Square_iStream.R         <= (others => Area_Compression_Pixel(color_select));
    Square_iStream.G         <= (others => Area_Compression_Pixel(color_select));
    Square_iStream.B         <= (others => Area_Compression_Pixel(color_select));
    Square_iStream.Column    <= Area_Compression_Column;
    Square_iStream.Row       <= Area_Compression_Row;
    Square_iStream.New_Pixel <= Area_Compression_New_Pixel;
    
    --Select color to output
    SIGNAL Blob_Out           : Blob_Data;
    Blob_Out.Busy  <= Blob_data_array(color_select).Busy;
    Blob_Out.Blobs <= Blob_data_array(color_select).Blobs;
    Blob_Out.X0    <= Blob_data_array(color_select).X0;
    Blob_Out.X1    <= Blob_data_array(color_select).X1;
    Blob_Out.Y0    <= Blob_data_array(color_select).Y0;
    Blob_Out.Y1    <= Blob_data_array(color_select).Y1;
    Generate (if Capture_Output < 6)
    {
        Blob_data_array(color_select).Addr <= Blob_Out.Addr;
    }
    
    SIGNAL Square_oStream : rgb_stream;
    
    --draw squares around blobs
    NewComponent Draw_Squares
    (
        Max_Square_Number => 32,
        Width             => 8,
        Color             => x"FF0000",

        Squares           => Blob_Out.Blobs,
        Square_Addr       => Blob_Out.Addr,
        Square_X0         => Blob_Out.X0,
        Square_X1         => Blob_Out.X1,
        Square_Y0         => Blob_Out.Y0,
        Square_Y1         => Blob_Out.Y1,
        iStream           => Square_iStream,
        oStream           => Square_oStream,
    );
    
    --Select cone color
    SIGNAL Cone_Out          : Cone_Data;
    Cone_Out.Busy  <= cone_data_array(cone_select).Busy;
    Cone_Out.Cones <= cone_data_array(cone_select).Cones;
    Cone_Out.X     <= cone_data_array(cone_select).X;
    Cone_Out.Y     <= cone_data_array(cone_select).Y;
    cone_data_array(cone_select).Addr <= Cone_Out.Addr;
    
    SIGNAL Cross_oStream : rgb_stream;
    
    --draw cross at cone position
    NewComponent Draw_Crosses
    (
        Max_Cross_Number => 16,
        Width            => 4,
        Length           => 20,
        Color            => x"FF0000",

        Crosses     => Cone_Out.Cones,
        Cross_Addr  => Cone_Out.Addr,
        Cross_X     => Cone_Out.X,
        Cross_Y     => Cone_Out.Y,
        iStream     => Square_iStream,
        oStream     => Cross_oStream,
    );

    --Select camera output---------------------------------------------------------------
    --0 = Camera, 1 = Color Filter, 2 = HSV,
    --3 = Threshold with Color_Select color, 4 = Compressed, 5 = Blobs, 6 = Cones
    
    Camera_Capture_iStream <= Camera_Stream when Capture_Output = 0 else
    Color_Correction_Stream when Capture_Output = 1 else
    RGB2HSV_Stream when Capture_Output = 2 else
    Yellow_Filter_Stream when Capture_Output = 3 AND Color_Select = 0 else
    Black_Filter_Stream when Capture_Output = 3 AND Color_Select = 1 else
    Blue_Filter_Stream when Capture_Output = 3 AND Color_Select = 2 else
    White_Filter_Stream when Capture_Output = 3 AND Color_Select = 3 else
    Square_iStream when Capture_Output = 4 else
    Square_oStream when Capture_Output = 5 else
    Cross_oStream;
    
    SIGNAL ISSP_source  : std_logic_vector (7 downto 0) := "00000000";
    SIGNAL ISSP1_source : std_logic_vector (7 downto 0) := "01001000";
    SIGNAL ISSP2_source : std_logic_vector (7 downto 0) := "00010001";
    SIGNAL ISSP3_source : std_logic_vector (7 downto 0) := "01001000";
    SIGNAL ISSP4_source : std_logic_vector (7 downto 0) := "00010001";
    SIGNAL ISSP_probe   : std_logic_vector (31 downto 0);
    SIGNAL ISSP1_probe  : std_logic_vector (31 downto 0);
    SIGNAL ISSP2_probe  : std_logic_vector (31 downto 0);
    SIGNAL ISSP3_probe  : std_logic_vector (31 downto 0);
    SIGNAL ISSP4_probe  : std_logic_vector (31 downto 0);
    
    NewComponent ISSP
    (
        source => ISSP_source,
        probe  => ISSP_probe,
    );

    NewComponent ISSP
    (
        source => ISSP1_source,
        probe  => ISSP1_probe,
    );
    
    NewComponent ISSP
    (
        source => ISSP2_source,
        probe  => ISSP2_probe,
    );
    
    NewComponent ISSP
    (
        source => ISSP3_source,
        probe  => ISSP3_probe,
    );
    
    NewComponent ISSP
    (
        source => ISSP4_source,
        probe  => ISSP4_probe,
    );
    
    ISSP_probe  <= STD_LOGIC_VECTOR(TO_UNSIGNED(Cone_Out.Cones, 32))           when Capture_Output = 6 else STD_LOGIC_VECTOR(TO_UNSIGNED(Blob_Out.Blobs, 32));
    ISSP1_probe <= STD_LOGIC_VECTOR(TO_UNSIGNED(Cone_Out.X, 32))               when Capture_Output = 6 else STD_LOGIC_VECTOR(TO_UNSIGNED(Blob_Out.X0, 32));
    ISSP2_probe <= STD_LOGIC_VECTOR(TO_UNSIGNED(Cone_Out.Y, 32))               when Capture_Output = 6 else STD_LOGIC_VECTOR(TO_UNSIGNED(Blob_Out.Y0, 32));
    ISSP3_probe <= STD_LOGIC_VECTOR(TO_UNSIGNED(Cone_Out.Addr, 32))            when Capture_Output = 6 else STD_LOGIC_VECTOR(TO_UNSIGNED(Blob_Out.X1-Blob_Out.X0, 32));
    ISSP4_probe <= STD_LOGIC_VECTOR(TO_UNSIGNED(blob_data_array(2).Blobs, 32)) when Capture_Output = 6 else STD_LOGIC_VECTOR(TO_UNSIGNED(Blob_Out.Y1-Blob_Out.Y0, 32));

    --Output image with HDMI-------------------------------------------------------------

    --Save images in RAM
    SIGNAL Camera_Capture_Read_Column    : NATURAL          range 0 to 639;
    SIGNAL Camera_Capture_Read_Row       : NATURAL          range 0 to 479;
    SIGNAL Camera_Capture_Read_Data      : STD_LOGIC_VECTOR (23 downto 0);
    SIGNAL Camera_Capture_SDRAM_Read_Ena : STD_LOGIC;

    CONSTANT RGB   : BOOLEAN := (Capture_Output < 2 OR Capture_Output > 4) AND Color_Out;
    
    SIGNAL Camera_Capture_iStream     : rgb_stream;
    
    NewComponent Camera_Capture
    (
        Compression => capture_compression,
        Width       => Capture_Color_Depth,
        Full_Image  => Full_Image,
        RGB         => RGB,
        CLK_Edge    => false,

        New_Pixel   => Camera_Capture_iStream.New_Pixel,
        Column      => Camera_Capture_iStream.Column,
        Row         => Camera_Capture_iStream.Row,
        Pixel_R     => Camera_Capture_iStream.R,
        Pixel_G     => Camera_Capture_iStream.G,
        Pixel_B     => Camera_Capture_iStream.B,

        Read_Column => Camera_Capture_Read_Column,
        Read_Row    => Camera_Capture_Read_Row,
        Read_Data   => Camera_Capture_Read_Data,
    );

    
    --Read images from RAM to create video stream
    NewComponent CRT_Controller
    (
        image_size_div => 1,
        
        Read_Column => Camera_Capture_Read_Column,
        Read_Row    => Camera_Capture_Read_Row,
        Read_Data   => Camera_Capture_Read_Data,
        Read_Ena    => Camera_Capture_SDRAM_Read_Ena,
        VS_PCLK     => HDMI_Out_VS_PCLK,
        VS_SCLK     => HDMI_Out_VS_SCLK,
        VS_R        => HDMI_Out_VS_R,
        VS_G        => HDMI_Out_VS_G,
        VS_B        => HDMI_Out_VS_B,
        VS_HS       => HDMI_Out_VS_HS,
        VS_VS       => HDMI_Out_VS_VS,
        VS_DE       => HDMI_Out_VS_DE,
    );

    --Output video stream with hdmi interface
    SIGNAL HDMI_Out_VS_PCLK   : STD_LOGIC;
    SIGNAL HDMI_Out_VS_SCLK   : STD_LOGIC;
    SIGNAL HDMI_Out_VS_R      : STD_LOGIC_VECTOR (7 downto 0);
    SIGNAL HDMI_Out_VS_G      : STD_LOGIC_VECTOR (7 downto 0);
    SIGNAL HDMI_Out_VS_B      : STD_LOGIC_VECTOR (7 downto 0);
    SIGNAL HDMI_Out_VS_HS     : STD_LOGIC;
    SIGNAL HDMI_Out_VS_VS     : STD_LOGIC;
    SIGNAL HDMI_Out_VS_DE     : STD_LOGIC;

    NewComponent HDMI_Out
    (
        VS_PCLK    => HDMI_Out_VS_PCLK,
        VS_SCLK    => HDMI_Out_VS_SCLK,
        VS_R       => HDMI_Out_VS_R,
        VS_G       => HDMI_Out_VS_G,
        VS_B       => HDMI_Out_VS_B,
        VS_HS      => HDMI_Out_VS_HS,
        VS_VS      => HDMI_Out_VS_VS,
        VS_DE      => HDMI_Out_VS_DE,
        oHDMI_DATA => oHDMI_TX,
        oHDMI_CLK  => oHDMI_CLK,
        iHDMI_HPD  => iHDMI_HPD,
    );
}