/*
Compresses image depending on image area
-> closer objects are lower on the image and farther objects higher -> compresses lower parts and keeps higher parts
Only works with BW and 1 Bit images
 */

--!!!Bildbreite vierteln indem vor HSV 4 Pixel in einer Reihe zusammengefasst werden (braucht keinen RAM)
--Danach überall mit voller Höhe aber 1/4 Breite arbeiten

Component AreaLimitedCompression
(
    Generic
    (
        Image_Width : NATURAL := 640;
        Image_Height: NATURAL := 480;
        MAX_Area_O  : NATURAL := 4;  --Maximum number of pixels in area
        MAX_Area    : NATURAL range 1 to 24 := 10; --3 = 3x3 pixels used to create one blurred pixel
        MIN_Area    : NATURAL range 1 to 24 := 1;
        Colors      : NATURAL := 1;
        Start_Row   : NATURAL := 0;
        CLK_Edge    : BOOLEAN := true; --true = rising edge
    );
    iPixel     : IN STD_LOGIC_VECTOR(Colors-1 downto 0);
    iColumn    : IN NATURAL range 0 to Image_Width-1;
    iRow       : IN NATURAL range 0 to Image_Height-1;
    iNew_Pixel : IN STD_LOGIC;
    
    oPixel     : OUT STD_LOGIC_VECTOR(Colors-1 downto 0);
    oColumn    : OUT NATURAL range 0 to Image_Width-1;
    oRow       : OUT NATURAL range 0 to Image_Height-1;
    oNew_Pixel : OUT STD_LOGIC;
)
{
    SIGNAL iPixel_buf    : STD_LOGIC_VECTOR(Colors-1 downto 0);
    SIGNAL oPixel_buf    : STD_LOGIC_VECTOR(Colors-1 downto 0);
    
    oNew_Pixel <= iNew_Pixel;

    TYPE last_pixel_sub_row_type IS ARRAY (NATURAL range <>) OF STD_LOGIC_VECTOR(Colors-1 downto 0);
    TYPE last_pixel_row_type IS ARRAY (NATURAL range <>) OF last_pixel_sub_row_type(MAX_Area-1 downto 0);
    
    SIGNAL New_Pixel_Buf : STD_LOGIC;
    New_Pixel_Buf <= iNew_Pixel when CLK_Edge else NOT iNew_Pixel;
    
    --!!!! In Buffer immer Summe von einer Spalte speichern, da man so das summieren der Reihen spart
    
    TYPE col_add IS ARRAY (Colors-1 downto 0) OF NATURAL range 0 to MAX_Area*2;
    TYPE matrix_add IS ARRAY (Colors-1 downto 0) OF NATURAL range 0 to MAX_Area**2;
    
    TYPE sum_matrix_type IS ARRAY (NATURAL range <>) OF col_add;
    SIGNAL sum_matrix : sum_matrix_type(Image_Width-1 downto 0);
    
    Process ()
    {
        If(rising_edge(New_Pixel_Buf))
        {
            iPixel_buf <= iPixel;
            oPixel <= oPixel_buf;
            
            oColumn <= iColumn-2-(area_width/2);
            oRow    <= iRow-1-(area_width/2);
            
            VARIABLE area_width    : NATURAL range 1 to 24;
            CONSTANT row_divider   : NATURAL := (Image_Height-Start_Row)/(MAX_Area-MIN_Area+1);
            
            --Calculate area to combine
            If(iRow < Start_Row)
            {
                area_width := MAX_Area;
            }
            Else
            {
                area_width := (iRow-Start_Row)/row_divider+MIN_Area;
            }
            
            --Set Pixel for values that cannot be calculated
            If(iRow <= area_width OR iColumn <= area_width+1)
            {
                oPixel <= (others => '0');
            }
            
            VARIABLE r_add : matrix_add;
            
            VARIABLE sum_buf_i : col_add;
            VARIABLE sum_buf_o : col_add;
            
            -- Add to column sum
            sum_buf_i := sum_matrix(iColumn);
            For(i IN 0 to Colors-1)
            {
                sum_buf_o(i) := sum_buf_i(i) + TO_INTEGER("0" & iPixel(i));
            }
            
            If(add_r = area_width-1)
            {
                --Add columns
                For(k IN 0 to Colors-1)
                {
                    r_add(k) := r_add(k) + sum_buf_o(k);
                }
                
                If(add_c = area_width-1)
                {
                    For(k IN 0 to Colors-1)
                    {
                        If(r_add(k) > (MAX_Area_O*area_width**2)/(MAX_Area**2))
                        {
                            oPixel(k) <= '1';
                        }
                        Else
                        {
                            oPixel(k) <= '0';
                        }
                    }
                    r_add := (others => 0);
                }
                
                sum_buf_o := (others => 0);
            }
            
            VARIABLE add_c : NATURAL range 0 to MAX_Area-1 := 0;
            
            If(add_c < area_width-1)
            {
                add_c := add_c + 1;
            }
            Else
            {
                add_c := 0;
            }
            
            VARIABLE row_reg : NATURAL range 0 to Image_Height-1 := 0;
            VARIABLE add_r   : NATURAL range 0 to MAX_Area-1 := 0;
            
            If(row_reg /= iRow)
            {
                If(add_r < area_width-1)
                {
                    add_r := add_r + 1;
                }
                Else
                {
                    add_r := 0;
                }
            }
            row_reg := iRow;
            
            sum_matrix(iColumn) <= sum_buf_o;
        }
    }
}