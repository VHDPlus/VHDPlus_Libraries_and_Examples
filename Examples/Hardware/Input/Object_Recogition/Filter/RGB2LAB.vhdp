/*
Like with LAB this ouputs the brightness and the proportion of green to red and yellow to blue
This is verry simplified version that is less focused on the real LAB value but to help with image recognition
The brighter  the pixel the higher  L (0 to 255)
The greener   the pixel the smaller A (127 downto 0)
The reder     the pixel the higher  A (127 to 255)
The yellower  the pixel the higher  B (127 to 255)
The bluer     the pixel the lower   B (127 downto 0)
 */

Component RGB2FakeLAB_Filter
(
    iPixel_R   : IN STD_LOGIC_VECTOR (7 downto 0);
    iPixel_G   : IN STD_LOGIC_VECTOR (7 downto 0);
    iPixel_B   : IN STD_LOGIC_VECTOR (7 downto 0);
    iColumn    : IN NATURAL range 0 to 639 := 0;
    iRow       : IN NATURAL range 0 to 479 := 0;
    iNew_Pixel : IN STD_LOGIC;
    
    oPixel_R   : OUT STD_LOGIC_VECTOR (7 downto 0);
    oPixel_G   : OUT STD_LOGIC_VECTOR (7 downto 0);
    oPixel_B   : OUT STD_LOGIC_VECTOR (7 downto 0);
    oLAB_L     : OUT STD_LOGIC_VECTOR (7 downto 0);
    oLAB_A     : OUT STD_LOGIC_VECTOR (7 downto 0);
    oLAB_B     : OUT STD_LOGIC_VECTOR (7 downto 0);
    oColumn    : BUFFER NATURAL range 0 to 639 := 0;
    oRow       : BUFFER NATURAL range 0 to 479 := 0;
    oNew_Pixel : BUFFER STD_LOGIC;
)
{
    CONSTANT l_weight_r : NATURAL := 3;
    CONSTANT l_weight_g : NATURAL := 5;
    CONSTANT l_weight_b : NATURAL := 2;
    
    CONSTANT a_weight_r : INTEGER := 3;
    CONSTANT a_weight_g : INTEGER := -5;
    CONSTANT a_weight_b : INTEGER := 2;
    
    CONSTANT b_weight_r : INTEGER := 2;
    CONSTANT b_weight_g : INTEGER := 3;
    CONSTANT b_weight_b : INTEGER := -5;
    
    Process Calc ()
    {
        If(rising_edge(iNew_Pixel))
        {
            VARIABLE l_val : UNSIGNED (11 downto 0);
            VARIABLE a_val : SIGNED (11 downto 0);
            VARIABLE b_val : SIGNED (11 downto 0);

            l_val := TO_UNSIGNED(TO_INTEGER(UNSIGNED(iPixel_R))*l_weight_r + TO_INTEGER(UNSIGNED(iPixel_G))*l_weight_g + TO_INTEGER(UNSIGNED(iPixel_B))*l_weight_b, 12);
            a_val := TO_SIGNED(TO_INTEGER(UNSIGNED(iPixel_R))*a_weight_r + TO_INTEGER(UNSIGNED(iPixel_G))*a_weight_g + TO_INTEGER(UNSIGNED(iPixel_B))*a_weight_b, 12);
            b_val := TO_SIGNED(TO_INTEGER(UNSIGNED(iPixel_R))*b_weight_r + TO_INTEGER(UNSIGNED(iPixel_G))*b_weight_g + TO_INTEGER(UNSIGNED(iPixel_B))*b_weight_b, 12);
            
            l_val := shift_right(l_val,3); --2550/8
            If(l_val > 255)
            {
                l_val := TO_UNSIGNED(255, l_val'LENGTH);
            }

            a_val := shift_right(a_val,3) + 127; --/8+127
            b_val := shift_right(b_val,3) + 127;
            If(a_val > 255)
            {
                a_val := TO_SIGNED(255, a_val'LENGTH);
            }
            Elsif(a_val < 0)
            {
                a_val := (others => '0');
            }
            If(b_val > 255)
            {
                b_val := TO_SIGNED(255, b_val'LENGTH);
            }
            Elsif(b_val < 0)
            {
                b_val := (others => '0');
            }
            oLAB_A <= STD_LOGIC_VECTOR(UNSIGNED(abs(a_val))(7 downto 0));
            oLAB_B <= STD_LOGIC_VECTOR(UNSIGNED(abs(b_val))(7 downto 0));
            oLAB_L <= STD_LOGIC_VECTOR(l_val(7 downto 0));
            
            oPixel_R <= iPixel_R;
            oPixel_G <= iPixel_G;
            oPixel_B <= iPixel_B;
        }
    }
    
    Process Col_Row_Shift ()
    {
        If(rising_edge(iNew_Pixel))
        {
            oColumn    <= iColumn;
            oRow       <= iRow;
        }
    }
    
    oNew_Pixel <= iNew_Pixel;
}