Component RGB2HSV_Filter
(
    iPixel_R   : IN STD_LOGIC_VECTOR (7 downto 0);
    iPixel_G   : IN STD_LOGIC_VECTOR (7 downto 0);
    iPixel_B   : IN STD_LOGIC_VECTOR (7 downto 0);

    oPixel_H     : OUT STD_LOGIC_VECTOR (7 downto 0);
    oPixel_S     : OUT STD_LOGIC_VECTOR (7 downto 0);
    oPixel_V     : OUT STD_LOGIC_VECTOR (7 downto 0);
)
{
    signal r_int, g_int, b_int : integer;
    signal max_value, min_value, delta : integer;
    signal h_value, s_value, v_value : unsigned(7 downto 0);
    
    -- rgb conversion from ycc
    r_int <= to_integer(unsigned(iPixel_R));
    g_int <= to_integer(unsigned(iPixel_G));
    b_int <= to_integer(unsigned(iPixel_B));
    
    -- min, max, and delta values
    max_value <= r_int when (r_int > g_int and r_int > b_int) else
    g_int when (g_int > r_int and g_int > b_int) else
    b_int;
    min_value <= r_int when (r_int < g_int and r_int < b_int) else
    g_int when (g_int < r_int and g_int < b_int) else
    b_int;
    
    -- converion signals
    h_value <= to_unsigned(((30*(g_int-b_int))/delta mod 45900)/255, 8) when (r_int = max_value and delta /= 0) else
    to_unsigned((30*(b_int-r_int))/delta + 60, 8) when (g_int = max_value and delta /= 0) else
    to_unsigned((30*(r_int-g_int))/delta + 120, 8) when (b_int = max_value and delta /= 0) else
    to_unsigned(0, 8);
    s_value <= to_unsigned((255*delta)/max_value, 8) when (max_value /= 0) else to_unsigned(0, 8);
    v_value <= to_unsigned(max_value, 8);
    
    SIGNAL hue, saturation, value : unsigned(7 downto 0);
    
    -- perform limiting
    hue <= h_value;
    saturation <= s_value;
    value <= v_value;
    
    oPixel_H <= std_logic_vector(hue) when hue <= 180 else std_logic_vector(to_unsigned(180, 8));
    
    oPixel_S <= std_logic_vector(saturation) when saturation <= 255 else std_logic_vector(to_unsigned(255, 8));
    
    oPixel_V <= std_logic_vector(value) when value <= 255 else std_logic_vector(to_unsigned(255, 8));
}
