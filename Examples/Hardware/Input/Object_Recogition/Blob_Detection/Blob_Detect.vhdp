--Neuen Blonb buffern

Component Blob_Detect
(
    Generic
    (
        Blob_Number     : NATURAL := 32;
        Blob_Buffer     : NATURAL := 8;
        
        Width           : NATURAL := 640;
        Height          : NATURAL := 480;
        Min_Blob_Width  : NATURAL := 4;
        Min_Blob_Height : NATURAL := 2;
        Max_Blob_Width  : NATURAL := 20;
        Max_Blob_Height : NATURAL := 15;
        
        Upscale_Mult    : NATURAL := 4;
        Upscale_Start   : NATURAL := 100; --Upscale_End - Height increases scale of blobs
    );
    New_Pixel : IN STD_LOGIC;
    Pixel_In  : IN STD_LOGIC; --'1' for object and '0' for surrounding area
    Column    : IN NATURAL range 0 to 639;
    Row       : IN NATURAL range 0 to 479;
    
    Blob_Busy : OUT STD_LOGIC := '0';
    Blobs     : BUFFER NATURAL range 0 to Blob_Number-1;
    Blob_Addr : IN  NATURAL range 0 to Blob_Number-1;
    Blob_X0   : OUT NATURAL range 0 to Width-1;
    Blob_X1   : OUT NATURAL range 0 to Width-1;
    Blob_Y0   : OUT NATURAL range 0 to Height-1;
    Blob_Y1   : OUT NATURAL range 0 to Height-1;
)
{
    --Needed for 9bit RAM input
    CONSTANT Compression : NATURAL := 2;
    
    --  ->000011111100000
    --  00001111100111000
    --  00000011001111110
    --  00001111111101100
    --  00000000011000000
    
    --Wenn 1 -> 1. Anfang speichern und bis 0 gehen 2. gucken ob schon blob mit xa0 <= xn1 und xa1 >= xn0 gibt und ya1 = yn1-1
    
    TYPE blob_type IS RECORD
    x0 : NATURAL range 0 to Width-1;
    x1 : NATURAL range 0 to Width-1;
    y0 : NATURAL range 0 to Height-1;
    y1 : NATURAL range 0 to Height-1;
    END RECORD blob_type;
    
    TYPE blob_array IS ARRAY (natural range <>) OF blob_type;
    SIGNAL blob_reg : blob_array(0 to Blob_Buffer-1);

    --ALLES MIT STD_LOGIC MACHEM DAMIT RAM

    SIGNAL blob_ram_data_in  : STD_LOGIC_VECTOR (35 downto 0);
    SIGNAL blob_ram_data_out : STD_LOGIC_VECTOR (35 downto 0);
    
    SIGNAL blob_ram_copy_in  : STD_LOGIC_VECTOR (35 downto 0);
    SIGNAL blob_ram_copy_out : STD_LOGIC_VECTOR (35 downto 0);
    
    SIGNAL blob_ram_copy_addr_in  : NATURAL range 0 to Blob_Number-1;
    SIGNAL blob_ram_copy_addr_out : NATURAL range 0 to Blob_Number-1;
    
    SIGNAL blob_in      : blob_type;
    SIGNAL in_blob_num  : NATURAL range 0 to Blob_Number-1;
    
    Function log2 (return natural; x : positive)
    {
        variable i : natural;
        i := 0;
        While(2**i < x and i < 31)
        {
            i := i + 1;
        }
        return i;
    }
    
    NewComponent ALTSYNCRAM
    (
        address_reg_b => "CLOCK0",
        clock_enable_input_a => "BYPASS",
        clock_enable_input_b => "BYPASS",
        clock_enable_output_b => "BYPASS",
        intended_device_family => "Cyclone 10 LP",
        numwords_a => Blob_Number,
        numwords_b => Blob_Number,
        operation_mode => "DUAL_PORT",
        outdata_reg_b => "CLOCK0",
        widthad_a => log2(Blob_Number),
        widthad_b => log2(Blob_Number),
        width_a => 36,
        width_b => 36,
        width_byteena_a => 1,
        
        address_a => STD_LOGIC_VECTOR(TO_UNSIGNED(blob_ram_copy_addr_in,log2(Blob_Number))),
        address_b => STD_LOGIC_VECTOR(TO_UNSIGNED(Blob_Addr,log2(Blob_Number))),
        clock0 => New_Pixel,
        data_a => blob_ram_copy_in,
        wren_a => '1',
        q_b => blob_ram_data_out,
    );
    
    NewComponent ALTSYNCRAM
    (
        address_reg_b => "CLOCK0",
        clock_enable_input_a => "BYPASS",
        clock_enable_input_b => "BYPASS",
        clock_enable_output_b => "BYPASS",
        intended_device_family => "Cyclone 10 LP",
        numwords_a => Blob_Number,
        numwords_b => Blob_Number,
        operation_mode => "DUAL_PORT",
        outdata_reg_b => "CLOCK0",
        widthad_a => log2(Blob_Number),
        widthad_b => log2(Blob_Number),
        width_a => 36,
        width_b => 36,
        width_byteena_a => 1,
        
        address_a => STD_LOGIC_VECTOR(TO_UNSIGNED(in_blob_num,log2(Blob_Number))),
        address_b => STD_LOGIC_VECTOR(TO_UNSIGNED(blob_ram_copy_addr_out,log2(Blob_Number))),
        clock0 => New_Pixel,
        data_a => blob_ram_data_in,
        wren_a => '1',
        q_b => blob_ram_copy_out,
    );

    blob_ram_data_in <= STD_LOGIC_VECTOR(TO_UNSIGNED(blob_in.y1, 9)) & STD_LOGIC_VECTOR(TO_UNSIGNED(blob_in.y0, 9)) &
    STD_LOGIC_VECTOR(TO_UNSIGNED(blob_in.x1/Compression, 9)) & STD_LOGIC_VECTOR(TO_UNSIGNED(blob_in.x0/Compression, 9));
    
    Blob_X0 <= TO_INTEGER(UNSIGNED(blob_ram_data_out(8 downto 0)))*Compression;
    Blob_X1 <= TO_INTEGER(UNSIGNED(blob_ram_data_out(17 downto 9)))*Compression;
    Blob_Y0 <= TO_INTEGER(UNSIGNED(blob_ram_data_out(26 downto 18)));
    Blob_Y1 <= TO_INTEGER(UNSIGNED(blob_ram_data_out(35 downto 27)));
    
    SIGNAL used_blobs : STD_LOGIC_VECTOR (0 to Blob_Buffer-1) := (others => '0');
    SIGNAL next_blob : NATURAL range 0 to Blob_Buffer;
    
    --!!!!!
    --Es müssen blobs die abgeschlossen sind (ya1 < yn1-1) in Buffer geschrieben werden und die zu bearbeitenden jeden CLK Zyklus geprüft werden, um LEs zu spaaren
    
    Process ()
    {
        If(rising_edge(New_Pixel))
        {
            VARIABLE Row_Reg      : NATURAL range 0 to Height-1 := 0;

            VARIABLE start_x : NATURAL range 0 to Width-1 := 0;
            VARIABLE start_x_reg : NATURAL range 0 to Width-1 := 0;
            VARIABLE end_x   : NATURAL range 0 to Width-1 := 0;
            
            VARIABLE cur_blob : NATURAL range 0 to Blob_Number-1;
            
            VARIABLE Pixel_In_Reg : STD_LOGIC;
            
            If(copy)
            {
                Blob_Busy <= '1';
            }
            Else
            {
                Blob_Busy <= '0';
            }
            
            If(Row < Row_Reg)
            {
                VARIABLE copy : BOOLEAN;
                copy := true;
                Blobs <= 0;
                find_i := 0;
            }
            Row_Reg := Row;

            If(Pixel_In = '1' AND Pixel_In_Reg = '0')
            {
                start_x_reg := Column;
            }
            
            If(Pixel_In = '0' AND Pixel_In_Reg = '1' AND found)
            {
                end_x := Column;
                start_x := start_x_reg;
                
                VARIABLE found  : BOOLEAN;
                VARIABLE find_i : NATURAL range 0 to Blob_Buffer;
                found  := false;
                find_i := 0;
            }
            
            VARIABLE calc_max_h : NATURAL range 0 to Height-1;
            VARIABLE calc_max_w : NATURAL range 0 to Width-1;
            VARIABLE calc_min_h : NATURAL range 0 to Height-1;
            VARIABLE calc_min_w : NATURAL range 0 to Width-1;
            
            VARIABLE scale : NATURAL range 1 to Upscale_Mult+1 := 1;
            If(Row > Upscale_Start)
            {
                scale := (((Row-Upscale_Start)*Upscale_Mult) / (Height-Upscale_Start))+1;
            }
            Else
            {
                scale := 1;
            }
            
            If(scale > Upscale_Mult)
            {
                scale := Upscale_Mult;
            }
            
            calc_max_h := Max_Blob_Height * scale;
            calc_max_w := Max_Blob_Width * scale;
            calc_min_h := Min_Blob_Height * scale;
            calc_min_w := Min_Blob_Width * scale;

            If(not found or copy)
            {
                If(find_i < Blob_Buffer)
                {
                    If(used_blobs(find_i) = '1')
                    {
                        VARIABLE x0_reg : NATURAL range 0 to Width-1;
                        VARIABLE x1_reg : NATURAL range 0 to Width-1;
                        VARIABLE y0_reg : NATURAL range 0 to Height-1;
                        VARIABLE y1_reg : NATURAL range 0 to Height-1;
                        x0_reg := blob_reg(find_i).x0;
                        x1_reg := blob_reg(find_i).x1;
                        y0_reg := blob_reg(find_i).y0;
                        y1_reg := blob_reg(find_i).y1;
                        --Muss zwei Blobs verbinden wenn für 2 Blobs geht
                        If(NOT copy AND x0_reg <= end_x AND x1_reg >= start_x AND y1_reg >= Row-1)
                        {
                            found := true;
                            blob_reg(find_i).y1 <= Row;
                            
                            If(x0_reg > start_x)
                            {
                                x0_reg := start_x;
                            }
                            If(x1_reg < end_x)
                            {
                                x1_reg := end_x;
                            }
                            
                            --Delete if too big
                            If(x1_reg-x0_reg > calc_max_w OR y1_reg-y0_reg > calc_max_h)
                            {
                                used_blobs(find_i) <= '0';
                                If(find_i < next_blob)
                                {
                                    next_blob <= find_i;
                                }
                            }
                            Else
                            {
                                blob_reg(find_i).x0 <= x0_reg;
                                blob_reg(find_i).x1 <= x1_reg;
                            }
                            
                        }
                        Elsif(y1_reg < Row-1 OR copy)
                        {
                            --Delete in buffer and copy to main buffer if big enoght
                            If(y1_reg-y0_reg >= calc_min_h AND x1_reg-x0_reg >= calc_min_w)
                            {
                                blob_in <= blob_reg(find_i);
                                in_blob_num <= cur_blob;
                                cur_blob := cur_blob + 1;
                            }
                            used_blobs(find_i) <= '0';
                            If(find_i < next_blob)
                            {
                                next_blob <= find_i;
                            }
                        }
                    }

                    For(i IN 0 to Blob_Buffer-1)
                    {
                        If(used_blobs(i) = '1' AND i > find_i)
                        {
                            find_i := i;
                        }
                        Elsif(i = Blob_Buffer-1)
                        {
                            find_i := Blob_Buffer;
                        }
                    }
                }
                Elsif(copy)
                {
                    If(Blobs > 0)
                    {
                        blob_ram_copy_addr_in  <= Blobs-1;
                        blob_ram_copy_in <= blob_ram_copy_out;
                    }
                    
                    If(cur_blob > 0)
                    {
                        blob_ram_copy_addr_out <= Blobs;
                        Blobs <= Blobs + 1;
                        cur_blob := cur_blob - 1;
                    }
                    Else
                    {
                        copy       := false;
                        next_blob  <= 0;
                        used_blobs <= (others => '0');
                    }
                }
                Else
                {
                    If(next_blob < Blob_Buffer)
                    {
                        blob_reg(next_blob).x0 <= start_x;
                        blob_reg(next_blob).x1 <= end_x;
                        blob_reg(next_blob).y0 <= Row;
                        blob_reg(next_blob).y1 <= Row;
                        used_blobs(next_blob) <= '1';
                        For(i IN 0 to Blob_Buffer-1)
                        {
                            If(used_blobs(i) = '0' AND i /= next_blob)
                            {
                                next_blob <= i;
                            }
                            Elsif(i = Blob_Buffer-1)
                            {
                                next_blob <= Blob_Buffer;
                            }
                        }
                    }
                    Else
                    {
                        next_blob  <= 0;
                        used_blobs <= (others => '0');
                        --Gucken ob aktueller Blob wichtiger sein könnte?
                    }
                    found := true;
                }
            }
            
            Pixel_In_Reg := Pixel_In;
        }
    }
}